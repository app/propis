diff --git a/src/grammar.pegjs b/src/grammar.pegjs
index 704518e..75363b4 100644
--- a/src/grammar.pegjs
+++ b/src/grammar.pegjs
@@ -5,9 +5,9 @@ var CS = require("./nodes"),
     { ';': CS.SeqOp
     , '=': CS.AssignOp
     , '&&': CS.LogicalAndOp
-    , and: CS.LogicalAndOp
+    , и: CS.LogicalAndOp
     , '||': CS.LogicalOrOp
-    , or: CS.LogicalOrOp
+    , 'или': CS.LogicalOrOp
     , '|': CS.BitOrOp
     , '^': CS.BitXorOp
     , '&': CS.BitAndOp
@@ -195,15 +195,15 @@ postfixControlFlowExpression
             postfix = postfixContainer[1],
             indicator = postfix.type;
         switch(indicator){
-          case 'if':
-          case 'unless':
-            constructor = ('unless' === indicator) ? CS.NegatedConditional : CS.Conditional;
-            cond = ('unless' === indicator) ? new CS.LogicalNotOp(postfix.cond).g() : postfix.cond;
+          case 'если':
+          case 'еслине':
+            constructor = ('еслине' === indicator) ? CS.NegatedConditional : CS.Conditional;
+            cond = ('еслине' === indicator) ? new CS.LogicalNotOp(postfix.cond).g() : postfix.cond;
             return rp(new constructor(cond, expr, null));
           case 'while':
           case 'until':
-            constructor = ('unless' === indicator) ? CS.NegatedWhile : CS.While;
-            cond = ('unless' === indicator) ? new CS.LogicalNotOp(postfix.cond).g() : postfix.cond;
+            constructor = ('еслине' === indicator) ? CS.NegatedWhile : CS.While;
+            cond = ('еслине' === indicator) ? new CS.LogicalNotOp(postfix.cond).g() : postfix.cond;
             return rp(new constructor(cond, expr));
           case 'for-in':
             return rp(new CS.ForIn(postfix.val, postfix.key, postfix.list, postfix.step, postfix.filter, expr));
@@ -501,8 +501,8 @@ spread
 
 conditional
   = kw:(IF / UNLESS) _ cond:assignmentExpression body:conditionalBody elseClause:elseClause? {
-      var constructor = 'unless' === kw ? CS.NegatedConditional : CS.Conditional;
-      if('unless' === kw) cond = new CS.LogicalNotOp(cond).g();
+      var constructor = 'еслине' === kw ? CS.NegatedConditional : CS.Conditional;
+      if('еслине' === kw) cond = new CS.LogicalNotOp(cond).g();
       return rp(new constructor(cond, body.block, elseClause || null));
     }
   conditionalBody
@@ -624,16 +624,16 @@ forIn
 
 switch
   = SWITCH _ e:(expressionworthy / assignmentExpression)? body:switchBody {
-      return rp(new CS.Switch(e || null, body.cases, body['else'] || null));
+      return rp(new CS.Switch(e || null, body.cases, body['иначе'] || null));
     }
   switchBody
-    = _ TERMINDENT b:switchBlock DEDENT { return r({cases: b.cases, 'else': b['else']}); }
+    = _ TERMINDENT b:switchBlock DEDENT { return r({cases: b.cases, 'иначе': b['иначе']}); }
     / _ THEN _ c:case { return r({cases: [c]}); }
     / _ THEN { return r({cases: []}); }
   switchBlock
     = c:case cs:(_ TERMINATOR _ case)* elseClause:(_ TERMINATOR _ elseClause)? TERMINATOR? {
         var cases = [c].concat(cs.map(function(w){ return w[3]; }));
-        return r({cases: cases, 'else': elseClause ? elseClause[3] : null});
+        return r({cases: cases, 'иначе': elseClause ? elseClause[3] : null});
       }
   case
     = WHEN _ conditions:caseConditions body:caseBody {
@@ -966,7 +966,7 @@ TERMINDENT = $(TERMINATOR INDENT)
 
 
 // keywords
-AND = $("and" !identifierPart)
+AND = $("и" !identifierPart)
 BREAK = $("break" !identifierPart)
 BY = $("by" !identifierPart)
 CATCH = $("catch" !identifierPart)
@@ -975,12 +975,12 @@ CLASS = $("class" !identifierPart)
 DELETE = $("delete" !identifierPart)
 DEBUGGER = $("debugger" !identifierPart)
 DO = $("do" !identifierPart)
-ELSE = $("else" !identifierPart)
+ELSE = $("иначе" !identifierPart)
 EXTENDS = $("extends" !identifierPart)
 FALSE = $("false" !identifierPart)
 FINALLY = $("finally" !identifierPart)
 FOR = $("for" !identifierPart)
-IF = $("if" !identifierPart)
+IF = $("если" !identifierPart)
 IN = $("in" !identifierPart)
 INSTANCEOF = $("instanceof" !identifierPart)
 IS = $("is" !identifierPart)
@@ -993,7 +993,7 @@ NULL = $("null" !identifierPart)
 OF = $("of" !identifierPart)
 OFF = $("off" !identifierPart)
 ON = $("on" !identifierPart)
-OR = $("or" !identifierPart)
+OR = $("или" !identifierPart)
 OWN = $("own" !identifierPart)
 RETURN = $("return" !identifierPart)
 SWITCH = $("switch" !identifierPart)
@@ -1004,7 +1004,7 @@ TRUE = $("true" !identifierPart)
 TRY = $("try" !identifierPart)
 TYPEOF = $("typeof" !identifierPart)
 UNDEFINED = $("undefined" !identifierPart)
-UNLESS = $("unless" !identifierPart)
+UNLESS = $("еслине" !identifierPart)
 UNTIL = $("until" !identifierPart)
 WHEN = $("when" !identifierPart)
 WHILE = $("while" !identifierPart)
@@ -1013,7 +1013,7 @@ YES = $("yes" !identifierPart)
 SharedKeywords
   = ("true" / "false" / "null" / "this" / "new" / "delete" / "typeof" /
   "instanceof" / "in" / "return" / "throw" / "break" / "continue" / "debugger" /
-  "if" / "else" / "switch" / "for" / "while" / "do" / "try" / "catch" /
+  "если" /"иначе" / "switch" / "for" / "while" / "do" / "try" / "catch" /
   "finally" / "class" / "extends" / "super") !identifierPart
 
 JSKeywords
@@ -1022,8 +1022,8 @@ JSKeywords
   "package" / "private" / "protected" / "public" / "static" / "yield") !identifierPart
 
 CSKeywords
-  = ("undefined" / "then" / "unless" / "until" / "loop" / "off" / "by" / "when" /
-  "and" / "or" / "isnt" / "is" / "not" / "yes" / "no" / "on" / "of") !identifierPart
+  = ("undefined" / "then" / "еслине" / "until" / "loop" / "off" / "by" / "when" /
+  "или" / "и" / "isnt" / "is" / "not" / "yes" / "no" / "on" / "of") !identifierPart
 
 StandardPredefinedMacros
   = "__" ("FILENAME" / "LINE" / "DATETIMEMS" / "DATE" / "TIME") "__"
