diff --git a/test/assignment.coffee b/test/assignment.coffee
index afadf17..e1e0190 100644
--- a/test/assignment.coffee
+++ b/test/assignment.coffee
@@ -27,24 +27,24 @@ suite 'Assignment', ->
       nonce = {}
 
       a  = 0
-      a or= nonce
+      a или= nonce
       eq nonce, a
 
       b  = 1
-      b or= nonce
+      b или= nonce
       eq 1, b
 
       c = 0
-      c and= nonce
+      c и= nonce
       eq 0, c
 
       d = 1
-      d and= nonce
+      d и= nonce
       eq nonce, d
 
       # ensure that RHS is treated as a group
       e = f = false
-      e and= f or true
+      e и= f or true
       eq false, e
 
     test "compound assignment as a sub expression", ->
@@ -67,7 +67,7 @@ suite 'Assignment', ->
     #  eq 2, list[2]
     #  eq 2, count
 
-    #  list[count++] and= 6
+    #  list[count++] и= 6
     #  eq 6, list[2]
     #  eq 3, count
 
@@ -90,7 +90,7 @@ suite 'Assignment', ->
 
       eq 1, obj.one
 
-      obj and=
+      obj и=
         two: 2
 
       eq undefined, obj.one
@@ -211,7 +211,7 @@ suite 'Assignment', ->
 
     test "destructuring assignment against an expression", ->
       a={}; b={}
-      [y, z] = if true then [a, b] else [b, a]
+      [y, z] = если true then [a, b] иначе [b, a]
       eq a, y
       eq b, z
 
@@ -293,7 +293,7 @@ suite 'Assignment', ->
       obj = {}
       obj.temp ?= 0
       eq obj.temp, 0
-      obj.temp or= 100
+      obj.temp или= 100
       eq obj.temp, 100
 
     test "#1348, #1216: existential assignment compilation", ->
@@ -304,7 +304,7 @@ suite 'Assignment', ->
       #the first ?= compiles into a statement; the second ?= compiles to a ternary expression
       eq a ?= b ?= 1, nonce
 
-      if a then a ?= 2 else a = 3
+      если a then a ?= 2 иначе a = 3
       eq a, nonce
 
     #test "#1591, #1101: splatted expressions in destructuring assignment must be assignable", ->
diff --git a/test/classes.coffee b/test/classes.coffee
index be696e6..5f66abe 100644
--- a/test/classes.coffee
+++ b/test/classes.coffee
@@ -151,9 +151,9 @@ suite 'Classes', ->
     #test 'exectuable class bodies', ->
     #
     #  class A
-    #    if true
+    #    если true
     #      b: 'b'
-    #    else
+    #    иначе
     #      c: 'c'
     #
     #  a = new A
@@ -166,9 +166,9 @@ suite 'Classes', ->
       class Base
         @attr = (name) ->
           @::[name] = (val) ->
-            if arguments.length > 0
+            если arguments.length > 0
               @["_#{name}"] = val
-            else
+            иначе
               @["_#{name}"]
 
       class Robot extends Base
@@ -467,7 +467,7 @@ suite 'Classes', ->
     #
     #  # Ensure that constructors invoked with splats cache the function.
     #  called = 0
-    #  get = -> if called++ then false else class Type
+    #  get = -> если called++ then false иначе class Type
     #  new get() args...
 
     test '`new` shouldn\'t add extra parens', ->
diff --git a/test/debugger.coffee b/test/debugger.coffee
index f42d361..9021eb5 100644
--- a/test/debugger.coffee
+++ b/test/debugger.coffee
@@ -15,4 +15,4 @@ suite 'Debugger', ->
 
   test 'function with conditional debugger as last statement', ->
     x = true
-    if x then debugger
+    если x then debugger
diff --git a/test/function-invocation.coffee b/test/function-invocation.coffee
index 51faacd..8439f29 100644
--- a/test/function-invocation.coffee
+++ b/test/function-invocation.coffee
@@ -4,7 +4,7 @@ suite 'Function Invocation', ->
 # * Splats in Function Invocations
 # * Implicit Returns
 # * Explicit Returns
-  id = (_) -> if arguments.length is 1 then _ else [].slice.call arguments
+  id = (_) -> если arguments.length is 1 then _ иначе [].slice.call arguments
 
   test "basic argument passing", ->
     a = {}
@@ -51,7 +51,7 @@ suite 'Function Invocation', ->
 
   test "function invocation", ->
     func = ->
-      return if true
+      return если true
     eq undefined, func()
     result = ("hello".slice) 3
     ok result is 'lo'
@@ -134,9 +134,9 @@ suite 'Function Invocation', ->
   #    2 + 1
   #  )
 
-  test "Implicit call with a trailing if statement as a param.", ->
+  test "Implicit call with a trailing если statement as a param.", ->
     func = -> arguments[1]
-    result = func 'one', if false then 100 else 13
+    result = func 'one', если false then 100 иначе 13
     ok result is 13
 
   #test "Test more function passing:", ->
@@ -243,7 +243,7 @@ suite 'Function Invocation', ->
     ok (func --val) is 5
 
   test "jashkenas/coffee-script#855: execution context for `func arr...` should be `null`", ->
-    contextTest = -> eq @, if window? then window else global
+    contextTest = -> eq @, если window? then window иначе global
     array = []
     contextTest array
     contextTest.apply null, array
@@ -339,9 +339,9 @@ suite 'Function Invocation', ->
   test "implicit returns with multiple branches", ->
     nonce = {}
     fn = ->
-      if not nonce
+      если not nonce
         null
-      else
+      иначе
         nonce
     eq nonce, fn()
 
@@ -350,15 +350,15 @@ suite 'Function Invocation', ->
     fn = ->
       switch nonce
         when nonce then nonce
-        else return undefined
+        иначе return undefined
     eq nonce, fn()
 
   test "preserve context when generating closure wrappers for expression conversions", ->
     nonce = {}
     obj = {property: nonce, method: ->
-      this.result = if false
+      this.result = если false
         10
-      else
+      иначе
         "a"
         "b"
         this.property
@@ -371,7 +371,7 @@ suite 'Function Invocation', ->
   #  items = [0, 1, 2, 3, nonce, 4, 5]
   #  fn = (items) ->
   #    for item in items
-  #      return item if item is nonce
+  #      return item если item is nonce
   #  eq nonce, fn items
 
   test "usage of `new` is careful about where the invocation parens end up", ->
@@ -389,15 +389,15 @@ suite 'Function Invocation', ->
         'false'
     eq result, 'false'
 
-    save if id false
+    save если id false
       'false'
-    else
+    иначе
       'true'
     eq result, 'true'
 
-    save unless id false
+    save еслине id false
       'true'
-    else
+    иначе
       'false'
     eq result, 'true'
 
diff --git a/test/functions.coffee b/test/functions.coffee
index ee1446f..a549eb0 100644
--- a/test/functions.coffee
+++ b/test/functions.coffee
@@ -38,7 +38,7 @@ suite 'Function Literals', ->
 
     test "#1859: inline function bodies shouldn't modify prior postfix ifs", ->
       list = [1, 2, 3]
-      ok true if list.some (x) -> x is 2
+      ok true если list.some (x) -> x is 2
 
 
   suite 'Bound Function Definition', ->
@@ -207,4 +207,4 @@ suite 'Function Literals', ->
       (->) -> throw {}
       (->) ->
         a = Math.random()
-        if a then throw {}
+        если a then throw {}
diff --git a/test/operators.coffee b/test/operators.coffee
index 54531e2..aab5557 100644
--- a/test/operators.coffee
+++ b/test/operators.coffee
@@ -105,7 +105,7 @@ suite 'Operators', ->
   suite 'Existential Operator (Unary)', ->
 
     test "postfix existential operator", ->
-      ok (if nonexistent? then false else true)
+      ok (если nonexistent? then false иначе true)
       defined = true
       ok defined?
       defined = false
@@ -114,36 +114,36 @@ suite 'Operators', ->
     test "postfix existential operator only evaluates its operand once", ->
       semaphore = 0
       fn = ->
-        ok false if semaphore
+        ok false если semaphore
         ++semaphore
-      ok(if fn()? then true else false)
+      ok(если fn()? then true иначе false)
 
     test "negated postfix existential operator", ->
       ok !nothing?.value
 
     test "postfix existential operator on expressions", ->
-      eq true, (1 or 0)?, true
+      eq true, (1 или 0)?, true
 
 
   suite '`is`,`isnt`,`==`,`!=`', ->
 
     test "`==` and `is` should be interchangeable", ->
       a = b = 1
-      ok a is 1 and b == 1
+      ok a is 1 и b == 1
       ok a == b
       ok a is b
 
     test "`!=` and `isnt` should be interchangeable", ->
       a = 0
       b = 1
-      ok a isnt 1 and b != 0
+      ok a isnt 1 и b != 0
       ok a != b
       ok a isnt b
 
 
   suite '[not] in/of', ->
-    # - `in` should check if an array contains a value using `indexOf`
-    # - `of` should check if a property is defined on an object using `in`
+    # - `in` should check если an array contains a value using `indexOf`
+    # - `of` should check если a property is defined on an object using `in`
 
     test "in, of", ->
       arr = [1]
@@ -174,13 +174,13 @@ suite 'Operators', ->
       eq 1, [Object() in Array()].length
 
     test "jashkenas/coffee-script#737: `in` should have higher precedence than logical operators", ->
-      eq 1, 1 in [1] and 1
+      eq 1, 1 in [1] и 1
 
     test "jashkenas/coffee-script#768: `in` should preserve evaluation order", ->
       share = 0
-      a = -> share++ if share is 0
-      b = -> share++ if share is 1
-      c = -> share++ if share is 2
+      a = -> share++ если share is 0
+      b = -> share++ если share is 1
+      c = -> share++ если share is 2
       ok a() not in [b(),c()]
       eq 3, share
 
@@ -193,9 +193,9 @@ suite 'Operators', ->
       eq 9 in [3, a...], true
 
     test "jashkenas/coffee-script#1100: precedence in or-test compilation of `in`", ->
-      ok 0 in [1 and 0]
-      ok 0 in [1, 1 and 0]
-      ok not (0 in [1, 0 or 1])
+      ok 0 in [1 и 0]
+      ok 0 in [1, 1 и 0]
+      ok not (0 in [1, 0 или 1])
 
     test "jashkenas/coffee-script#1630: `in` should check `hasOwnProperty`", ->
       ok undefined not in {length: 1}
@@ -227,8 +227,8 @@ suite 'Operators', ->
     ok 1 < 2 > 1
     ok 10 < 20 > 2+3 is 5
 
-  test "some chainable operators can be negated by `unless`", ->
-    ok (true unless 0==10!=100)
+  test "some chainable operators can be negated by `еслине`", ->
+    ok (true еслине 0==10!=100)
 
   test "operator precedence: `|` lower than `<`", ->
     eq 1, 1 | 2 < 3 < 4
@@ -244,8 +244,8 @@ suite 'Operators', ->
     ok 1 > a++ < 1
 
   #test "jashkenas/coffee-script#891: incorrect inversion of chained comparisons", ->
-  #  ok (true unless 0 > 1 > 2)
-  #  ok (true unless (NaN = 0/0) < 0/0 < NaN)
+  #  ok (true еслине 0 > 1 > 2)
+  #  ok (true еслине (NaN = 0/0) < 0/0 < NaN)
 
   test "jashkenas/coffee-script#1234: Applying a splat to :: applies the splat to the wrong object", ->
     nonce = {}
@@ -271,7 +271,7 @@ suite 'Operators', ->
 
   test "jashkenas/coffee-script#2155: conditional assignment to a closure", ->
     x = null
-    func = -> x ?= (-> if true then 'hi')
+    func = -> x ?= (-> если true then 'hi')
     func()
     eq x(), 'hi'
 
diff --git a/test/optimisations.coffee b/test/optimisations.coffee
index 6821390..bd791b4 100644
--- a/test/optimisations.coffee
+++ b/test/optimisations.coffee
@@ -11,9 +11,9 @@ suite 'Optimisations', ->
       delete global.thisShouldBeInTheGlobalScope
 
     test 'do not optimise away declarations in conditionals', ->
-      if 0 then a = 0
+      если 0 then a = 0
       eq undefined, a
-      if 1 then 0 else b = 0
+      если 1 then 0 иначе b = 0
       eq undefined, b
 
     test 'do not optimise away declarations in while loops', ->
diff --git a/test/scope.coffee b/test/scope.coffee
index a84a1b5..19ab9a1 100644
--- a/test/scope.coffee
+++ b/test/scope.coffee
@@ -21,9 +21,9 @@ suite 'Scope', ->
 
   test 'vars are function-scoped, not block-scoped', ->
     fn = -> true
-    if fn()
+    если fn()
       a = 1
-    else
+    иначе
       a = 0
     ok a
 
diff --git a/test/setup.coffee b/test/setup.coffee
index 457b518..b8bfc1a 100644
--- a/test/setup.coffee
+++ b/test/setup.coffee
@@ -5,16 +5,16 @@ global[name] = func for name, func of require 'assert'
 
 # See http://wiki.ecmascript.org/doku.php?id=harmony:egal
 egal = (a, b) ->
-  if a is b
-    a isnt 0 or 1/a is 1/b
-  else
-    a isnt a and b isnt b
+  если a is b
+    a isnt 0 или 1/a is 1/b
+  иначе
+    a isnt a и b isnt b
 
 # A recursive functional equivalence helper; uses egal for testing equivalence.
 arrayEgal = (a, b) ->
-  if egal a, b then yes
-  else if a instanceof Array and b instanceof Array
-    return no unless a.length is b.length
+  если egal a, b then yes
+  иначе если a instanceof Array и b instanceof Array
+    return no еслине a.length is b.length
     return no for el, idx in a when not arrayEgal el, b[idx]
     yes
 
@@ -22,7 +22,7 @@ global.eq      = (a, b, msg) -> ok egal(a, b), msg ? "#{inspect a} === #{inspect
 global.arrayEq = (a, b, msg) -> ok arrayEgal(a,b), msg ? "#{inspect a} === #{inspect b}"
 
 
-libDir = if typeof _$jscoverage is 'undefined' then 'lib' else 'instrumented'
+libDir = если typeof _$jscoverage is 'undefined' then 'lib' иначе 'instrumented'
 global.CoffeeScript = require '..'
 global.CS = require "../#{libDir}/coffee-script/nodes"
 global.JS = require "../#{libDir}/coffee-script/js-nodes"
